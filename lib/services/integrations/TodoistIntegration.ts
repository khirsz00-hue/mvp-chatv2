/**
 * Todoist Integration
 * Wraps existing Todoist sync logic into the unified task system
 * Phase 1: Mapping logic only - full sync in Phase 2
 */

import { BaseTaskIntegration } from './BaseTaskIntegration'
import { UnifiedTask, TaskSource } from '@/lib/types/unifiedTasks'
import { getTodoistToken } from '@/lib/integrations'

export class TodoistIntegration extends BaseTaskIntegration {
  name = 'todoist'
  
  async isEnabled(userId: string): Promise<boolean> {
    const token = await getTodoistToken(userId)
    return token !== null
  }
  
  /**
   * Map Todoist task to internal UnifiedTask format
   * Uses existing mapping logic from dayAssistantSync.ts
   */
  mapToInternal(todoistTask: any, userId: string, assistantId: string): UnifiedTask {
    const priority = this.mapTodoistPriority(todoistTask)
    
    return {
      // All fields from TestDayTask
      id: '', // will be generated by DB
      user_id: userId,
      assistant_id: assistantId,
      title: todoistTask.content,
      description: todoistTask.description || null,
      priority,
      is_must: todoistTask.labels?.includes('@must') || false,
      is_important: todoistTask.priority >= 3,
      estimate_min: todoistTask.duration?.amount || 15,
      cognitive_load: this.mapCognitiveLoad(todoistTask),
      tags: todoistTask.labels || [],
      context_type: this.mapContextType(todoistTask),
      due_date: todoistTask.due?.date || null,
      completed: todoistTask.is_completed || false,
      completed_at: null,
      position: 0,
      postpone_count: 0,
      moved_from_date: null,
      moved_reason: null,
      last_moved_at: null,
      auto_moved: false,
      metadata: {
        todoist_priority: todoistTask.priority,
        todoist_project_id: todoistTask.project_id,
      },
      created_at: todoistTask.created_at || new Date().toISOString(),
      updated_at: new Date().toISOString(),
      
      // New unified fields
      source: 'todoist' as TaskSource,
      external_id: String(todoistTask.id),
      external_metadata: {
        project_id: todoistTask.project_id,
        labels: todoistTask.labels,
        parent_id: todoistTask.parent_id,
        order: todoistTask.order,
        url: todoistTask.url,
      },
      last_synced_at: new Date().toISOString(),
      sync_status: 'synced',
      
      // Legacy compatibility
      todoist_id: todoistTask.id,
      todoist_task_id: todoistTask.id,
    } as UnifiedTask
  }
  
  /**
   * Map Todoist priority to internal priority
   * Copied from existing sync logic
   */
  private mapTodoistPriority(task: any): number {
    // Check for special labels first
    if (task.labels?.includes('@now')) return 1
    if (task.labels?.includes('@next')) return 2
    if (task.labels?.includes('@later')) return 3
    
    // Todoist priority: 1=lowest, 4=highest
    // Internal priority: 1=highest, 4=lowest
    return 5 - (task.priority || 1)
  }
  
  /**
   * Map task duration to cognitive load
   * Simple heuristic based on estimate
   */
  private mapCognitiveLoad(task: any): number {
    const estimate = task.duration?.amount || 15
    if (estimate <= 15) return 1
    if (estimate <= 30) return 2
    if (estimate <= 60) return 3
    if (estimate <= 120) return 4
    return 5
  }
  
  /**
   * Map Todoist task to context type
   * Phase 1: Simplified, Phase 2: AI-powered
   */
  private mapContextType(task: any): string {
    // Check labels for context hints
    const labels = task.labels || []
    if (labels.includes('@code') || labels.includes('@dev')) return 'deep_work'
    if (labels.includes('@meeting') || labels.includes('@call')) return 'communication'
    if (labels.includes('@admin') || labels.includes('@paperwork')) return 'admin'
    if (labels.includes('@quick')) return 'quick_wins'
    if (labels.includes('@personal')) return 'personal'
    
    // Default to admin for now
    return 'admin'
  }
  
  /**
   * Map internal task to Todoist format
   * Phase 1: Not implemented, Phase 2: For bidirectional sync
   */
  mapToExternal(internalTask: UnifiedTask): any {
    throw new Error('Not implemented in Phase 1')
  }
  
  /**
   * Fetch tasks from Todoist
   * Phase 1: Placeholder, Phase 2: Use existing /api/todoist/tasks endpoint
   */
  async fetchTasks(userId: string): Promise<any[]> {
    return []
  }
  
  /**
   * Create task in Todoist
   * Phase 1: Not implemented, Phase 2: Integration
   */
  async createTask(task: UnifiedTask): Promise<any> {
    throw new Error('Not implemented in Phase 1')
  }
  
  /**
   * Update task in Todoist
   * Phase 1: Not implemented, Phase 2: Integration
   */
  async updateTask(task: UnifiedTask): Promise<any> {
    throw new Error('Not implemented in Phase 1')
  }
  
  /**
   * Delete task from Todoist
   * Phase 1: Not implemented, Phase 2: Integration
   */
  async deleteTask(externalId: string): Promise<void> {
    throw new Error('Not implemented in Phase 1')
  }
}
